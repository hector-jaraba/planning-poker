"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/socketio";
exports.ids = ["pages/api/socketio"];
exports.modules = {

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("mongoose");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("socket.io");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fsocketio&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fsocketio.js&middlewareConfigBase64=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fsocketio&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fsocketio.js&middlewareConfigBase64=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _src_pages_api_socketio_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/pages/api/socketio.js */ \"(api)/./src/pages/api/socketio.js\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_socketio_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_src_pages_api_socketio_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/socketio\",\n        pathname: \"/api/socketio\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _src_pages_api_socketio_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRnNvY2tldGlvJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGc3JjJTJGcGFnZXMlMkZhcGklMkZzb2NrZXRpby5qcyZtaWRkbGV3YXJlQ29uZmlnQmFzZTY0PWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDTDtBQUMxRDtBQUN3RDtBQUN4RDtBQUNBLGlFQUFlLHdFQUFLLENBQUMsdURBQVEsWUFBWSxFQUFDO0FBQzFDO0FBQ08sZUFBZSx3RUFBSyxDQUFDLHVEQUFRO0FBQ3BDO0FBQ08sd0JBQXdCLGdIQUFtQjtBQUNsRDtBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZO0FBQ1osQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2N1cnNvci1wbGFubmluZy1wb2tlci8/NGU0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vc3JjL3BhZ2VzL2FwaS9zb2NrZXRpby5qc1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCBcImRlZmF1bHRcIik7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCBcImNvbmZpZ1wiKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzQVBJUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTX0FQSSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3NvY2tldGlvXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvc29ja2V0aW9cIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fsocketio&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fsocketio.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./src/pages/api/socketio.js":
/*!***********************************!*\
  !*** ./src/pages/api/socketio.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io */ \"socket.io\");\n/* harmony import */ var socket_io__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(socket_io__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var mongoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mongoose */ \"mongoose\");\n/* harmony import */ var mongoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mongoose__WEBPACK_IMPORTED_MODULE_1__);\n\n\n// SessionModel definition\nlet SessionModel;\ntry {\n    // Try to get the model if it exists\n    SessionModel = mongoose__WEBPACK_IMPORTED_MODULE_1___default().model(\"Session\");\n} catch (e) {\n    // Define Session schema if not already defined\n    const SessionSchema = new (mongoose__WEBPACK_IMPORTED_MODULE_1___default().Schema)({\n        name: {\n            type: String,\n            required: true\n        },\n        ownerId: {\n            type: String,\n            required: true\n        },\n        participants: [\n            String\n        ],\n        tasks: [\n            {\n                title: {\n                    type: String,\n                    required: true\n                },\n                description: String,\n                jiraId: String,\n                status: {\n                    type: String,\n                    enum: [\n                        \"pending\",\n                        \"active\",\n                        \"completed\"\n                    ],\n                    default: \"pending\"\n                },\n                estimates: [\n                    {\n                        userId: String,\n                        value: (mongoose__WEBPACK_IMPORTED_MODULE_1___default().Schema).Types.Mixed\n                    }\n                ],\n                finalEstimate: (mongoose__WEBPACK_IMPORTED_MODULE_1___default().Schema).Types.Mixed\n            }\n        ],\n        estimationType: {\n            type: String,\n            enum: [\n                \"fibonacci\",\n                \"tshirt\"\n            ],\n            default: \"fibonacci\"\n        },\n        status: {\n            type: String,\n            enum: [\n                \"active\",\n                \"completed\"\n            ],\n            default: \"active\"\n        },\n        shareLink: String\n    });\n    // Create the model\n    SessionModel = mongoose__WEBPACK_IMPORTED_MODULE_1___default().model(\"Session\", SessionSchema);\n}\n// Connect to MongoDB\nconst connectDB = async ()=>{\n    try {\n        if ((mongoose__WEBPACK_IMPORTED_MODULE_1___default().connection).readyState === 0) {\n            await mongoose__WEBPACK_IMPORTED_MODULE_1___default().connect(process.env.MONGODB_URI);\n            console.log(\"MongoDB connected\");\n        }\n    } catch (error) {\n        console.error(\"MongoDB connection error:\", error);\n    }\n};\n// Track connected users and sessions\nconst connectedUsers = new Map();\nconst sessionRooms = new Map();\n// Track participants with their usernames for each session\nconst sessionParticipants = new Map();\nfunction handler(req, res) {\n    if (res.socket.server.io) {\n        console.log(\"Socket is already running\");\n        res.end();\n        return;\n    }\n    console.log(\"Setting up socket.io server...\");\n    const io = new socket_io__WEBPACK_IMPORTED_MODULE_0__.Server(res.socket.server, {\n        path: \"/api/socketio\",\n        addTrailingSlash: false\n    });\n    res.socket.server.io = io;\n    // Socket.io event handlers\n    io.on(\"connection\", async (socket)=>{\n        const { sessionId, userId, username } = socket.handshake.query;\n        if (!sessionId || !userId) {\n            socket.disconnect();\n            return;\n        }\n        // Clean and format username for display\n        const displayName = username ? String(username).trim() || `User ${userId.substring(0, 6)}` : `User ${userId.substring(0, 6)}`;\n        console.log(`User ${displayName} (${userId}) connected to session ${sessionId}`);\n        // Join the session room\n        socket.join(sessionId);\n        // Track connected users\n        connectedUsers.set(socket.id, {\n            userId,\n            username: displayName,\n            sessionId\n        });\n        // Track session participants with usernames\n        if (!sessionParticipants.has(sessionId)) {\n            sessionParticipants.set(sessionId, new Map());\n        }\n        sessionParticipants.get(sessionId).set(userId, {\n            username: displayName,\n            connected: true\n        });\n        // Track session participants\n        if (!sessionRooms.has(sessionId)) {\n            sessionRooms.set(sessionId, new Set());\n        }\n        sessionRooms.get(sessionId).add(socket.id);\n        // Send updated participant list to all users in the session\n        const participantsList = Array.from(sessionParticipants.get(sessionId).entries()).map(([id, data])=>({\n                userId: id,\n                username: data.username,\n                connected: data.connected\n            }));\n        console.log(\"Broadcasting participants list:\", participantsList);\n        io.to(sessionId).emit(\"participants_update\", participantsList);\n        // Notify other users in the room\n        socket.to(sessionId).emit(\"user_joined\", {\n            userId,\n            username: displayName\n        });\n        // Basic ping/pong for connection testing\n        socket.on(\"ping\", (data)=>{\n            console.log(`Ping received from ${displayName} (${userId}):`, data);\n            socket.emit(\"pong\", {\n                message: \"Server received ping\",\n                timestamp: Date.now()\n            });\n        });\n        // Event handlers for session activities\n        socket.on(\"submit_estimate\", async (data)=>{\n            try {\n                const { taskId, value } = data;\n                console.log(\"submit_estimate received:\", {\n                    taskId,\n                    value,\n                    userId,\n                    sessionId\n                });\n                await connectDB();\n                // Find the session\n                const session = await SessionModel.findById(sessionId);\n                if (!session) {\n                    console.error(\"Session not found:\", sessionId);\n                    return;\n                }\n                // Find the task\n                const task = session.tasks.find((t)=>t.id === taskId || t._id.toString() === taskId);\n                if (!task) {\n                    console.error(\"Task not found in session:\", taskId);\n                    return;\n                }\n                console.log(\"Processing estimate for task:\", task.title);\n                // Check if user already estimated\n                const existingEstimateIndex = task.estimates.findIndex((e)=>e.userId.toString() === userId.toString());\n                // Value can be null for \"?\" selections\n                const hasActualValue = value !== null && value !== undefined && value !== \"?\";\n                if (existingEstimateIndex >= 0) {\n                    // Update existing estimate\n                    console.log(\"Updating existing estimate for user:\", userId);\n                    task.estimates[existingEstimateIndex].value = hasActualValue ? value : null;\n                    task.estimates[existingEstimateIndex].hasEstimate = hasActualValue;\n                } else {\n                    // Add new estimate\n                    console.log(\"Adding new estimate for user:\", userId);\n                    task.estimates.push({\n                        userId: userId,\n                        value: hasActualValue ? value : null,\n                        hasEstimate: hasActualValue\n                    });\n                }\n                // Ensure task has a revealed property\n                if (task.revealed === undefined) {\n                    task.revealed = false;\n                }\n                // Save and broadcast update\n                await session.save();\n                console.log(\"Session saved with new estimate, emitting update\");\n                // Create a masked version where estimate values are hidden if not revealed\n                const sessionForBroadcast = JSON.parse(JSON.stringify(session));\n                // Mask ALL tasks that are not revealed, not just the current one\n                sessionForBroadcast.tasks.forEach((t)=>{\n                    // Make sure each task has the revealed property\n                    if (t.revealed === undefined) {\n                        t.revealed = false;\n                    }\n                    // If this task is not revealed, hide all estimates except the user's own\n                    if (t.revealed !== true) {\n                        t.estimates = t.estimates.map((e)=>{\n                            const isCurrentUser = e.userId.toString() === userId.toString();\n                            const hasValue = e.value !== undefined && e.value !== null;\n                            return {\n                                userId: e.userId,\n                                hasEstimate: hasValue || e.hasEstimate === true,\n                                // Only show actual value to the user who submitted it, otherwise use \"-\"\n                                value: isCurrentUser && hasValue ? e.value : isCurrentUser ? \"-\" : null\n                            };\n                        });\n                    }\n                });\n                console.log(\"Broadcasting session update with hidden estimates\");\n                io.to(sessionId).emit(\"session_update\", sessionForBroadcast);\n                // Also send an event indicating someone has estimated (without revealing the value)\n                io.to(sessionId).emit(\"user_estimated\", {\n                    userId,\n                    username: displayName,\n                    taskId: task._id.toString()\n                });\n            } catch (error) {\n                console.error(\"Error submitting estimate:\", error);\n            }\n        });\n        // Add a new event handler for revealing estimates\n        socket.on(\"reveal_estimates\", async (data)=>{\n            try {\n                const { taskId } = data;\n                console.log(\"reveal_estimates received:\", {\n                    taskId,\n                    userId,\n                    sessionId,\n                    fromAdmin: displayName\n                });\n                await connectDB();\n                // Find the session\n                const session = await SessionModel.findById(sessionId);\n                if (!session) {\n                    console.error(\"Session not found:\", sessionId);\n                    return;\n                }\n                // Find the task\n                const task = session.tasks.find((t)=>t.id === taskId || t._id.toString() === taskId);\n                if (!task) {\n                    console.error(\"Task not found in session:\", taskId);\n                    return;\n                }\n                // Set revealed flag to true\n                task.revealed = true;\n                // First, save session with revealed flag\n                await session.save();\n                console.log(\"Estimates revealed for task:\", task.title);\n                // Extract and prepare the actual estimate values from the task\n                const cleanEstimates = task.estimates.map((est)=>({\n                        userId: est.userId ? est.userId.toString() : est.userId,\n                        value: est.value,\n                        hasEstimate: est.value !== undefined && est.value !== null\n                    }));\n                console.log(\"Sending revealed estimates:\", cleanEstimates);\n                // First send the reveal event with full estimate data\n                io.to(sessionId).emit(\"estimates_revealed\", {\n                    taskId: task._id.toString(),\n                    estimates: cleanEstimates\n                });\n                // Then send full session update with all estimate values visible\n                const fullSessionCopy = JSON.parse(JSON.stringify(session));\n                // Make sure all estimates have proper values in all tasks\n                fullSessionCopy.tasks.forEach((t)=>{\n                    // Initialize revealed property if missing\n                    if (t.revealed === undefined) {\n                        t.revealed = t._id.toString() === taskId;\n                    }\n                    // For the revealed task, make sure all estimate data is complete\n                    if (t._id.toString() === taskId) {\n                        t.estimates = t.estimates.map((est)=>({\n                                userId: est.userId,\n                                value: est.value,\n                                hasEstimate: est.value !== undefined && est.value !== null\n                            }));\n                    }\n                });\n                // Send the complete session data\n                io.to(sessionId).emit(\"session_update\", fullSessionCopy);\n            } catch (error) {\n                console.error(\"Error revealing estimates:\", error);\n            }\n        });\n        // Add a new event handler for hiding estimates\n        socket.on(\"hide_estimates\", async (data)=>{\n            try {\n                const { taskId } = data;\n                console.log(\"hide_estimates received:\", {\n                    taskId,\n                    userId,\n                    sessionId,\n                    fromAdmin: displayName\n                });\n                await connectDB();\n                // Find the session\n                const session = await SessionModel.findById(sessionId);\n                if (!session) {\n                    console.error(\"Session not found:\", sessionId);\n                    return;\n                }\n                // Find the task\n                const task = session.tasks.find((t)=>t.id === taskId || t._id.toString() === taskId);\n                if (!task) {\n                    console.error(\"Task not found in session:\", taskId);\n                    return;\n                }\n                // Set revealed flag to false\n                task.revealed = false;\n                // Save and broadcast update\n                await session.save();\n                console.log(\"Estimates hidden for task:\", task.title);\n                // Broadcast the hide event first\n                io.to(sessionId).emit(\"estimates_hidden\", {\n                    taskId: task._id.toString()\n                });\n                // Create a masked version\n                const sessionForBroadcast = JSON.parse(JSON.stringify(session));\n                sessionForBroadcast.tasks.forEach((t)=>{\n                    // Make sure each task has the revealed property\n                    if (t.revealed === undefined) {\n                        t.revealed = false;\n                    }\n                    // If this task is not revealed, hide all estimates except the user's own\n                    if (t.revealed !== true) {\n                        t.estimates = t.estimates.map((e)=>({\n                                userId: e.userId,\n                                hasEstimate: e.value !== undefined && e.value !== null,\n                                // Only show actual value to the user who submitted it\n                                value: e.userId.toString() === userId.toString() ? e.value : null\n                            }));\n                    }\n                });\n                // Then send masked session update\n                io.to(sessionId).emit(\"session_update\", sessionForBroadcast);\n            } catch (error) {\n                console.error(\"Error hiding estimates:\", error);\n            }\n        });\n        socket.on(\"set_active_task\", async (data)=>{\n            try {\n                // Immediately acknowledge receipt\n                socket.emit(\"set_active_task_received\", {\n                    taskId: data?.taskId\n                });\n                const { taskId } = data || {};\n                if (!taskId) {\n                    console.error(\"Invalid taskId received:\", data);\n                    socket.emit(\"set_active_task_error\", {\n                        error: \"Invalid task ID\"\n                    });\n                    return;\n                }\n                console.log(\"set_active_task received:\", {\n                    taskId,\n                    userId,\n                    sessionId,\n                    taskIdType: typeof taskId\n                });\n                await connectDB();\n                // Find the session\n                const session = await SessionModel.findById(sessionId);\n                if (!session) {\n                    console.error(\"Session not found:\", sessionId);\n                    socket.emit(\"set_active_task_error\", {\n                        error: \"Session not found\"\n                    });\n                    return;\n                }\n                console.log(\"Session tasks:\", session.tasks.map((t)=>({\n                        id: t.id,\n                        _id: t._id?.toString(),\n                        title: t.title,\n                        status: t.status\n                    })));\n                // Update task status\n                let taskFound = false;\n                // First pass: Find the task to make active and remember current status of all tasks\n                const taskStatusMap = new Map();\n                session.tasks.forEach((task)=>{\n                    const taskIdStr = task._id.toString();\n                    taskStatusMap.set(taskIdStr, task.status);\n                });\n                // Second pass: Update statuses\n                session.tasks.forEach((task)=>{\n                    // Try different ways to match the task ID\n                    const taskIdStr = task._id.toString();\n                    const taskIdMatches = task.id === taskId || taskIdStr === taskId || task._id.toString() === taskId;\n                    if (taskIdMatches) {\n                        console.log(\"Setting task as active:\", {\n                            title: task.title,\n                            id: task.id,\n                            _id: task._id.toString(),\n                            previousStatus: task.status\n                        });\n                        task.status = \"active\";\n                        taskFound = true;\n                    } else if (task.status === \"active\") {\n                        console.log(\"Changing previously active task status:\", task.title);\n                        // If task was previously completed, keep it completed\n                        if (taskStatusMap.get(taskIdStr) === \"completed\") {\n                            task.status = \"completed\";\n                        } else {\n                            // Mark previous active task as completed when moving to a new task\n                            task.status = \"completed\";\n                        }\n                    } else {\n                        // Keep other tasks as they are (pending or completed)\n                        // This ensures completed tasks stay completed\n                        console.log(`Keeping task \"${task.title}\" as ${task.status}`);\n                    }\n                });\n                if (!taskFound) {\n                    console.error(\"No matching task found:\", taskId);\n                    socket.emit(\"set_active_task_error\", {\n                        error: \"Task not found\"\n                    });\n                    return;\n                }\n                // Save updated session\n                await session.save();\n                // Send success response\n                socket.emit(\"set_active_task_success\", {\n                    taskId,\n                    message: \"Task set as active successfully\"\n                });\n                // Broadcast session update to all users\n                io.to(sessionId).emit(\"session_update\", session);\n                console.log(\"Task set as active, session updated\");\n            } catch (error) {\n                console.error(\"Error setting active task:\", error);\n                socket.emit(\"set_active_task_error\", {\n                    error: \"Server error processing request\"\n                });\n            }\n        });\n        socket.on(\"add_task\", async (data)=>{\n            // First acknowledge receipt to keep the socket open\n            socket.emit(\"add_task_received\", {\n                status: \"received\",\n                message: \"Task request received by server\",\n                taskData: data\n            });\n            try {\n                const { title, description, jiraId } = data;\n                console.log(\"add_task received from:\", displayName, \"(\", userId, \")\", {\n                    title,\n                    description,\n                    jiraId,\n                    sessionId\n                });\n                // Double-check connection\n                if (!socket.connected) {\n                    console.error(\"Socket disconnected during task creation\");\n                    return;\n                }\n                try {\n                    await connectDB();\n                    // Find the session\n                    const session = await SessionModel.findById(sessionId);\n                    if (!session) {\n                        console.error(\"Session not found:\", sessionId);\n                        if (socket.connected) {\n                            socket.emit(\"add_task_error\", {\n                                error: \"Session not found\"\n                            });\n                        }\n                        return;\n                    }\n                    // Create new task with proper MongoDB document structure\n                    const newTask = {\n                        title,\n                        description: description || \"\",\n                        jiraId: jiraId || undefined,\n                        status: \"pending\",\n                        estimates: []\n                    };\n                    // Add task to session\n                    session.tasks.push(newTask);\n                    const newTaskId = session.tasks[session.tasks.length - 1]._id;\n                    console.log(\"Task added:\", {\n                        title: newTask.title,\n                        taskId: newTaskId\n                    });\n                    // Save session in a separate try block\n                    try {\n                        await session.save();\n                        console.log(\"Session saved with new task, emitting response\");\n                        // Check if socket is still connected\n                        if (socket.connected) {\n                            // First send a success confirmation to the task creator\n                            socket.emit(\"add_task_success\", {\n                                taskId: newTaskId.toString(),\n                                message: \"Task created successfully\"\n                            });\n                            // Then broadcast to all users in the room\n                            io.to(sessionId).emit(\"session_update\", session);\n                            console.log(\"Session update emitted to room\", sessionId);\n                        } else {\n                            console.warn(\"Socket disconnected before sending success response\");\n                        }\n                    } catch (saveError) {\n                        console.error(\"Error saving session:\", saveError);\n                        if (socket.connected) {\n                            socket.emit(\"add_task_error\", {\n                                error: \"Failed to save task\"\n                            });\n                        }\n                    }\n                } catch (dbError) {\n                    console.error(\"Database error:\", dbError);\n                    if (socket.connected) {\n                        socket.emit(\"add_task_error\", {\n                            error: \"Database error\"\n                        });\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error adding task:\", error);\n                if (socket.connected) {\n                    socket.emit(\"add_task_error\", {\n                        error: \"Server error processing task\"\n                    });\n                }\n            }\n        });\n        socket.on(\"refresh_session\", async ()=>{\n            try {\n                await connectDB();\n                // Find the session\n                const session = await SessionModel.findById(sessionId);\n                if (!session) return;\n                // Create a proper copy of the session with consistent formatting\n                const processedSession = JSON.parse(JSON.stringify(session));\n                // Ensure all tasks have proper revealed state and estimate formatting\n                processedSession.tasks.forEach((task)=>{\n                    // Initialize revealed if missing\n                    if (task.revealed === undefined) {\n                        task.revealed = false;\n                    }\n                    // For non-revealed tasks, mask estimates except for the current user\n                    if (task.revealed !== true) {\n                        task.estimates = task.estimates.map((est)=>{\n                            const isCurrentUser = est.userId && est.userId.toString() === userId.toString();\n                            const hasValue = est.value !== undefined && est.value !== null;\n                            return {\n                                userId: est.userId,\n                                hasEstimate: hasValue || est.hasEstimate === true,\n                                // Only show actual value to current user\n                                value: isCurrentUser && hasValue ? est.value : isCurrentUser ? \"-\" : null\n                            };\n                        });\n                    } else {\n                        // For revealed tasks, ensure all estimates have consistent structure\n                        task.estimates = task.estimates.map((est)=>({\n                                userId: est.userId,\n                                value: est.value,\n                                hasEstimate: est.value !== undefined && est.value !== null\n                            }));\n                    }\n                });\n                // Broadcast the processed session update\n                io.to(sessionId).emit(\"session_update\", processedSession);\n            } catch (error) {\n                console.error(\"Error refreshing session:\", error);\n            }\n        });\n        socket.on(\"set_final_estimate\", async (data)=>{\n            try {\n                const { taskId, estimate } = data;\n                console.log(\"set_final_estimate received:\", {\n                    taskId,\n                    estimate,\n                    userId,\n                    sessionId,\n                    fromAdmin: displayName\n                });\n                await connectDB();\n                // Find the session\n                const session = await SessionModel.findById(sessionId);\n                if (!session) {\n                    console.error(\"Session not found:\", sessionId);\n                    return;\n                }\n                // Find the task\n                const task = session.tasks.find((t)=>t.id === taskId || t._id.toString() === taskId);\n                if (!task) {\n                    console.error(\"Task not found in session:\", taskId);\n                    return;\n                }\n                // Set final estimate and mark task as completed\n                task.finalEstimate = estimate;\n                task.status = \"completed\";\n                task.revealed = true; // Make sure estimates are revealed with final estimate\n                // Save and broadcast update\n                await session.save();\n                console.log(\"Final estimate set for task:\", task.title, \"=\", estimate);\n                // Broadcast task completed event\n                io.to(sessionId).emit(\"task_completed\", {\n                    taskId: task._id.toString(),\n                    finalEstimate: estimate\n                });\n                // Send full session update\n                io.to(sessionId).emit(\"session_update\", session);\n            } catch (error) {\n                console.error(\"Error setting final estimate:\", error);\n            }\n        });\n        // Handle disconnection\n        socket.on(\"disconnect\", ()=>{\n            const userData = connectedUsers.get(socket.id);\n            if (userData) {\n                console.log(`User ${userData.username} disconnected from session ${userData.sessionId}`);\n                // Remove from connected users\n                connectedUsers.delete(socket.id);\n                // Update session participants\n                if (sessionParticipants.has(userData.sessionId) && sessionParticipants.get(userData.sessionId).has(userData.userId)) {\n                    sessionParticipants.get(userData.sessionId).get(userData.userId).connected = false;\n                    // Send updated participant list\n                    const participantsList = Array.from(sessionParticipants.get(userData.sessionId).entries()).map(([id, data])=>({\n                            userId: id,\n                            username: data.username,\n                            connected: data.connected\n                        }));\n                    io.to(userData.sessionId).emit(\"participants_update\", participantsList);\n                }\n                // Remove from session room\n                if (sessionRooms.has(userData.sessionId)) {\n                    sessionRooms.get(userData.sessionId).delete(socket.id);\n                    // If room is empty, cleanup\n                    if (sessionRooms.get(userData.sessionId).size === 0) {\n                        sessionRooms.delete(userData.sessionId);\n                        sessionParticipants.delete(userData.sessionId);\n                    }\n                }\n                // Notify other users in the room\n                socket.to(userData.sessionId).emit(\"user_left\", {\n                    userId: userData.userId,\n                    username: userData.username\n                });\n            }\n        });\n    });\n    res.end();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3RELFFBQVFxRyxTQUFTckcsTUFBTTtvQkFDdkJnQyxVQUFVcUUsU0FBU3JFLFFBQVE7Z0JBQzdCO1lBQ0Y7UUFDRjtJQUNGO0lBRUFULElBQUlJLEdBQUc7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2N1cnNvci1wbGFubmluZy1wb2tlci8uL3NyYy9wYWdlcy9hcGkvc29ja2V0aW8uanM/N2E4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXJ2ZXIgfSBmcm9tIFwic29ja2V0LmlvXCI7XG5pbXBvcnQgbW9uZ29vc2UgZnJvbSBcIm1vbmdvb3NlXCI7XG5cbi8vIFNlc3Npb25Nb2RlbCBkZWZpbml0aW9uXG5sZXQgU2Vzc2lvbk1vZGVsO1xuXG50cnkge1xuICAvLyBUcnkgdG8gZ2V0IHRoZSBtb2RlbCBpZiBpdCBleGlzdHNcbiAgU2Vzc2lvbk1vZGVsID0gbW9uZ29vc2UubW9kZWwoXCJTZXNzaW9uXCIpO1xufSBjYXRjaCAoZSkge1xuICAvLyBEZWZpbmUgU2Vzc2lvbiBzY2hlbWEgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICBjb25zdCBTZXNzaW9uU2NoZW1hID0gbmV3IG1vbmdvb3NlLlNjaGVtYSh7XG4gICAgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgb3duZXJJZDogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgcGFydGljaXBhbnRzOiBbU3RyaW5nXSxcbiAgICB0YXNrczogW1xuICAgICAge1xuICAgICAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBTdHJpbmcsXG4gICAgICAgIGppcmFJZDogU3RyaW5nLFxuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgZW51bTogW1wicGVuZGluZ1wiLCBcImFjdGl2ZVwiLCBcImNvbXBsZXRlZFwiXSxcbiAgICAgICAgICBkZWZhdWx0OiBcInBlbmRpbmdcIixcbiAgICAgICAgfSxcbiAgICAgICAgZXN0aW1hdGVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXNlcklkOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogbW9uZ29vc2UuU2NoZW1hLlR5cGVzLk1peGVkLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGZpbmFsRXN0aW1hdGU6IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5NaXhlZCxcbiAgICAgIH0sXG4gICAgXSxcbiAgICBlc3RpbWF0aW9uVHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZW51bTogW1wiZmlib25hY2NpXCIsIFwidHNoaXJ0XCJdLFxuICAgICAgZGVmYXVsdDogXCJmaWJvbmFjY2lcIixcbiAgICB9LFxuICAgIHN0YXR1czoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZW51bTogW1wiYWN0aXZlXCIsIFwiY29tcGxldGVkXCJdLFxuICAgICAgZGVmYXVsdDogXCJhY3RpdmVcIixcbiAgICB9LFxuICAgIHNoYXJlTGluazogU3RyaW5nLFxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG1vZGVsXG4gIFNlc3Npb25Nb2RlbCA9IG1vbmdvb3NlLm1vZGVsKFwiU2Vzc2lvblwiLCBTZXNzaW9uU2NoZW1hKTtcbn1cblxuLy8gQ29ubmVjdCB0byBNb25nb0RCXG5jb25zdCBjb25uZWN0REIgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKG1vbmdvb3NlLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gMCkge1xuICAgICAgYXdhaXQgbW9uZ29vc2UuY29ubmVjdChwcm9jZXNzLmVudi5NT05HT0RCX1VSSSk7XG4gICAgICBjb25zb2xlLmxvZyhcIk1vbmdvREIgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiTW9uZ29EQiBjb25uZWN0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gIH1cbn07XG5cbi8vIFRyYWNrIGNvbm5lY3RlZCB1c2VycyBhbmQgc2Vzc2lvbnNcbmNvbnN0IGNvbm5lY3RlZFVzZXJzID0gbmV3IE1hcCgpO1xuY29uc3Qgc2Vzc2lvblJvb21zID0gbmV3IE1hcCgpO1xuXG4vLyBUcmFjayBwYXJ0aWNpcGFudHMgd2l0aCB0aGVpciB1c2VybmFtZXMgZm9yIGVhY2ggc2Vzc2lvblxuY29uc3Qgc2Vzc2lvblBhcnRpY2lwYW50cyA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xuICBpZiAocmVzLnNvY2tldC5zZXJ2ZXIuaW8pIHtcbiAgICBjb25zb2xlLmxvZyhcIlNvY2tldCBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgcmVzLmVuZCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKFwiU2V0dGluZyB1cCBzb2NrZXQuaW8gc2VydmVyLi4uXCIpO1xuXG4gIGNvbnN0IGlvID0gbmV3IFNlcnZlcihyZXMuc29ja2V0LnNlcnZlciwge1xuICAgIHBhdGg6IFwiL2FwaS9zb2NrZXRpb1wiLFxuICAgIGFkZFRyYWlsaW5nU2xhc2g6IGZhbHNlLFxuICB9KTtcblxuICByZXMuc29ja2V0LnNlcnZlci5pbyA9IGlvO1xuXG4gIC8vIFNvY2tldC5pbyBldmVudCBoYW5kbGVyc1xuICBpby5vbihcImNvbm5lY3Rpb25cIiwgYXN5bmMgKHNvY2tldCkgPT4ge1xuICAgIGNvbnN0IHsgc2Vzc2lvbklkLCB1c2VySWQsIHVzZXJuYW1lIH0gPSBzb2NrZXQuaGFuZHNoYWtlLnF1ZXJ5O1xuXG4gICAgaWYgKCFzZXNzaW9uSWQgfHwgIXVzZXJJZCkge1xuICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiBhbmQgZm9ybWF0IHVzZXJuYW1lIGZvciBkaXNwbGF5XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSB1c2VybmFtZVxuICAgICAgPyBTdHJpbmcodXNlcm5hbWUpLnRyaW0oKSB8fCBgVXNlciAke3VzZXJJZC5zdWJzdHJpbmcoMCwgNil9YFxuICAgICAgOiBgVXNlciAke3VzZXJJZC5zdWJzdHJpbmcoMCwgNil9YDtcblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYFVzZXIgJHtkaXNwbGF5TmFtZX0gKCR7dXNlcklkfSkgY29ubmVjdGVkIHRvIHNlc3Npb24gJHtzZXNzaW9uSWR9YFxuICAgICk7XG5cbiAgICAvLyBKb2luIHRoZSBzZXNzaW9uIHJvb21cbiAgICBzb2NrZXQuam9pbihzZXNzaW9uSWQpO1xuXG4gICAgLy8gVHJhY2sgY29ubmVjdGVkIHVzZXJzXG4gICAgY29ubmVjdGVkVXNlcnMuc2V0KHNvY2tldC5pZCwge1xuICAgICAgdXNlcklkLFxuICAgICAgdXNlcm5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgc2Vzc2lvbklkLFxuICAgIH0pO1xuXG4gICAgLy8gVHJhY2sgc2Vzc2lvbiBwYXJ0aWNpcGFudHMgd2l0aCB1c2VybmFtZXNcbiAgICBpZiAoIXNlc3Npb25QYXJ0aWNpcGFudHMuaGFzKHNlc3Npb25JZCkpIHtcbiAgICAgIHNlc3Npb25QYXJ0aWNpcGFudHMuc2V0KHNlc3Npb25JZCwgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgc2Vzc2lvblBhcnRpY2lwYW50cy5nZXQoc2Vzc2lvbklkKS5zZXQodXNlcklkLCB7XG4gICAgICB1c2VybmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBUcmFjayBzZXNzaW9uIHBhcnRpY2lwYW50c1xuICAgIGlmICghc2Vzc2lvblJvb21zLmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICBzZXNzaW9uUm9vbXMuc2V0KHNlc3Npb25JZCwgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgc2Vzc2lvblJvb21zLmdldChzZXNzaW9uSWQpLmFkZChzb2NrZXQuaWQpO1xuXG4gICAgLy8gU2VuZCB1cGRhdGVkIHBhcnRpY2lwYW50IGxpc3QgdG8gYWxsIHVzZXJzIGluIHRoZSBzZXNzaW9uXG4gICAgY29uc3QgcGFydGljaXBhbnRzTGlzdCA9IEFycmF5LmZyb20oXG4gICAgICBzZXNzaW9uUGFydGljaXBhbnRzLmdldChzZXNzaW9uSWQpLmVudHJpZXMoKVxuICAgICkubWFwKChbaWQsIGRhdGFdKSA9PiAoe1xuICAgICAgdXNlcklkOiBpZCxcbiAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXJuYW1lLFxuICAgICAgY29ubmVjdGVkOiBkYXRhLmNvbm5lY3RlZCxcbiAgICB9KSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIkJyb2FkY2FzdGluZyBwYXJ0aWNpcGFudHMgbGlzdDpcIiwgcGFydGljaXBhbnRzTGlzdCk7XG4gICAgaW8udG8oc2Vzc2lvbklkKS5lbWl0KFwicGFydGljaXBhbnRzX3VwZGF0ZVwiLCBwYXJ0aWNpcGFudHNMaXN0KTtcblxuICAgIC8vIE5vdGlmeSBvdGhlciB1c2VycyBpbiB0aGUgcm9vbVxuICAgIHNvY2tldC50byhzZXNzaW9uSWQpLmVtaXQoXCJ1c2VyX2pvaW5lZFwiLCB7XG4gICAgICB1c2VySWQsXG4gICAgICB1c2VybmFtZTogZGlzcGxheU5hbWUsXG4gICAgfSk7XG5cbiAgICAvLyBCYXNpYyBwaW5nL3BvbmcgZm9yIGNvbm5lY3Rpb24gdGVzdGluZ1xuICAgIHNvY2tldC5vbihcInBpbmdcIiwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGBQaW5nIHJlY2VpdmVkIGZyb20gJHtkaXNwbGF5TmFtZX0gKCR7dXNlcklkfSk6YCwgZGF0YSk7XG4gICAgICBzb2NrZXQuZW1pdChcInBvbmdcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIlNlcnZlciByZWNlaXZlZCBwaW5nXCIsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gRXZlbnQgaGFuZGxlcnMgZm9yIHNlc3Npb24gYWN0aXZpdGllc1xuICAgIHNvY2tldC5vbihcInN1Ym1pdF9lc3RpbWF0ZVwiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0YXNrSWQsIHZhbHVlIH0gPSBkYXRhO1xuICAgICAgICBjb25zb2xlLmxvZyhcInN1Ym1pdF9lc3RpbWF0ZSByZWNlaXZlZDpcIiwge1xuICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBjb25uZWN0REIoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBTZXNzaW9uTW9kZWwuZmluZEJ5SWQoc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlNlc3Npb24gbm90IGZvdW5kOlwiLCBzZXNzaW9uSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHRhc2tcbiAgICAgICAgY29uc3QgdGFzayA9IHNlc3Npb24udGFza3MuZmluZChcbiAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGFza0lkIHx8IHQuX2lkLnRvU3RyaW5nKCkgPT09IHRhc2tJZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUYXNrIG5vdCBmb3VuZCBpbiBzZXNzaW9uOlwiLCB0YXNrSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBlc3RpbWF0ZSBmb3IgdGFzazpcIiwgdGFzay50aXRsZSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBhbHJlYWR5IGVzdGltYXRlZFxuICAgICAgICBjb25zdCBleGlzdGluZ0VzdGltYXRlSW5kZXggPSB0YXNrLmVzdGltYXRlcy5maW5kSW5kZXgoXG4gICAgICAgICAgKGUpID0+IGUudXNlcklkLnRvU3RyaW5nKCkgPT09IHVzZXJJZC50b1N0cmluZygpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVmFsdWUgY2FuIGJlIG51bGwgZm9yIFwiP1wiIHNlbGVjdGlvbnNcbiAgICAgICAgY29uc3QgaGFzQWN0dWFsVmFsdWUgPVxuICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IFwiP1wiO1xuXG4gICAgICAgIGlmIChleGlzdGluZ0VzdGltYXRlSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBlc3RpbWF0ZVxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRpbmcgZXhpc3RpbmcgZXN0aW1hdGUgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgdGFzay5lc3RpbWF0ZXNbZXhpc3RpbmdFc3RpbWF0ZUluZGV4XS52YWx1ZSA9IGhhc0FjdHVhbFZhbHVlXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgdGFzay5lc3RpbWF0ZXNbZXhpc3RpbmdFc3RpbWF0ZUluZGV4XS5oYXNFc3RpbWF0ZSA9IGhhc0FjdHVhbFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFkZCBuZXcgZXN0aW1hdGVcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkFkZGluZyBuZXcgZXN0aW1hdGUgZm9yIHVzZXI6XCIsIHVzZXJJZCk7XG4gICAgICAgICAgdGFzay5lc3RpbWF0ZXMucHVzaCh7XG4gICAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgIHZhbHVlOiBoYXNBY3R1YWxWYWx1ZSA/IHZhbHVlIDogbnVsbCxcbiAgICAgICAgICAgIGhhc0VzdGltYXRlOiBoYXNBY3R1YWxWYWx1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0YXNrIGhhcyBhIHJldmVhbGVkIHByb3BlcnR5XG4gICAgICAgIGlmICh0YXNrLnJldmVhbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXNrLnJldmVhbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGFuZCBicm9hZGNhc3QgdXBkYXRlXG4gICAgICAgIGF3YWl0IHNlc3Npb24uc2F2ZSgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNlc3Npb24gc2F2ZWQgd2l0aCBuZXcgZXN0aW1hdGUsIGVtaXR0aW5nIHVwZGF0ZVwiKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBtYXNrZWQgdmVyc2lvbiB3aGVyZSBlc3RpbWF0ZSB2YWx1ZXMgYXJlIGhpZGRlbiBpZiBub3QgcmV2ZWFsZWRcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkZvckJyb2FkY2FzdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbikpO1xuXG4gICAgICAgIC8vIE1hc2sgQUxMIHRhc2tzIHRoYXQgYXJlIG5vdCByZXZlYWxlZCwgbm90IGp1c3QgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIHNlc3Npb25Gb3JCcm9hZGNhc3QudGFza3MuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBlYWNoIHRhc2sgaGFzIHRoZSByZXZlYWxlZCBwcm9wZXJ0eVxuICAgICAgICAgIGlmICh0LnJldmVhbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHQucmV2ZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIHRhc2sgaXMgbm90IHJldmVhbGVkLCBoaWRlIGFsbCBlc3RpbWF0ZXMgZXhjZXB0IHRoZSB1c2VyJ3Mgb3duXG4gICAgICAgICAgaWYgKHQucmV2ZWFsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHQuZXN0aW1hdGVzID0gdC5lc3RpbWF0ZXMubWFwKChlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFVzZXIgPSBlLnVzZXJJZC50b1N0cmluZygpID09PSB1c2VySWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgY29uc3QgaGFzVmFsdWUgPSBlLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgZS52YWx1ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogZS51c2VySWQsXG4gICAgICAgICAgICAgICAgaGFzRXN0aW1hdGU6IGhhc1ZhbHVlIHx8IGUuaGFzRXN0aW1hdGUgPT09IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBzaG93IGFjdHVhbCB2YWx1ZSB0byB0aGUgdXNlciB3aG8gc3VibWl0dGVkIGl0LCBvdGhlcndpc2UgdXNlIFwiLVwiXG4gICAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgICBpc0N1cnJlbnRVc2VyICYmIGhhc1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgID8gZS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlzQ3VycmVudFVzZXJcbiAgICAgICAgICAgICAgICAgICAgPyBcIi1cIlxuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQnJvYWRjYXN0aW5nIHNlc3Npb24gdXBkYXRlIHdpdGggaGlkZGVuIGVzdGltYXRlc1wiKTtcbiAgICAgICAgaW8udG8oc2Vzc2lvbklkKS5lbWl0KFwic2Vzc2lvbl91cGRhdGVcIiwgc2Vzc2lvbkZvckJyb2FkY2FzdCk7XG5cbiAgICAgICAgLy8gQWxzbyBzZW5kIGFuIGV2ZW50IGluZGljYXRpbmcgc29tZW9uZSBoYXMgZXN0aW1hdGVkICh3aXRob3V0IHJldmVhbGluZyB0aGUgdmFsdWUpXG4gICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcInVzZXJfZXN0aW1hdGVkXCIsIHtcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgdXNlcm5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgIHRhc2tJZDogdGFzay5faWQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3VibWl0dGluZyBlc3RpbWF0ZTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGEgbmV3IGV2ZW50IGhhbmRsZXIgZm9yIHJldmVhbGluZyBlc3RpbWF0ZXNcbiAgICBzb2NrZXQub24oXCJyZXZlYWxfZXN0aW1hdGVzXCIsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHRhc2tJZCB9ID0gZGF0YTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcInJldmVhbF9lc3RpbWF0ZXMgcmVjZWl2ZWQ6XCIsIHtcbiAgICAgICAgICB0YXNrSWQsXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICBmcm9tQWRtaW46IGRpc3BsYXlOYW1lLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBjb25uZWN0REIoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBTZXNzaW9uTW9kZWwuZmluZEJ5SWQoc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlNlc3Npb24gbm90IGZvdW5kOlwiLCBzZXNzaW9uSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHRhc2tcbiAgICAgICAgY29uc3QgdGFzayA9IHNlc3Npb24udGFza3MuZmluZChcbiAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGFza0lkIHx8IHQuX2lkLnRvU3RyaW5nKCkgPT09IHRhc2tJZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUYXNrIG5vdCBmb3VuZCBpbiBzZXNzaW9uOlwiLCB0YXNrSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCByZXZlYWxlZCBmbGFnIHRvIHRydWVcbiAgICAgICAgdGFzay5yZXZlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gRmlyc3QsIHNhdmUgc2Vzc2lvbiB3aXRoIHJldmVhbGVkIGZsYWdcbiAgICAgICAgYXdhaXQgc2Vzc2lvbi5zYXZlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXN0aW1hdGVzIHJldmVhbGVkIGZvciB0YXNrOlwiLCB0YXNrLnRpdGxlKTtcblxuICAgICAgICAvLyBFeHRyYWN0IGFuZCBwcmVwYXJlIHRoZSBhY3R1YWwgZXN0aW1hdGUgdmFsdWVzIGZyb20gdGhlIHRhc2tcbiAgICAgICAgY29uc3QgY2xlYW5Fc3RpbWF0ZXMgPSB0YXNrLmVzdGltYXRlcy5tYXAoKGVzdCkgPT4gKHtcbiAgICAgICAgICB1c2VySWQ6IGVzdC51c2VySWQgPyBlc3QudXNlcklkLnRvU3RyaW5nKCkgOiBlc3QudXNlcklkLFxuICAgICAgICAgIHZhbHVlOiBlc3QudmFsdWUsIC8vIEluY2x1ZGUgdGhlIGFjdHVhbCBlc3RpbWF0ZSB2YWx1ZVxuICAgICAgICAgIGhhc0VzdGltYXRlOiBlc3QudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBlc3QudmFsdWUgIT09IG51bGwsXG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgcmV2ZWFsZWQgZXN0aW1hdGVzOlwiLCBjbGVhbkVzdGltYXRlcyk7XG5cbiAgICAgICAgLy8gRmlyc3Qgc2VuZCB0aGUgcmV2ZWFsIGV2ZW50IHdpdGggZnVsbCBlc3RpbWF0ZSBkYXRhXG4gICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcImVzdGltYXRlc19yZXZlYWxlZFwiLCB7XG4gICAgICAgICAgdGFza0lkOiB0YXNrLl9pZC50b1N0cmluZygpLFxuICAgICAgICAgIGVzdGltYXRlczogY2xlYW5Fc3RpbWF0ZXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoZW4gc2VuZCBmdWxsIHNlc3Npb24gdXBkYXRlIHdpdGggYWxsIGVzdGltYXRlIHZhbHVlcyB2aXNpYmxlXG4gICAgICAgIGNvbnN0IGZ1bGxTZXNzaW9uQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbikpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZXN0aW1hdGVzIGhhdmUgcHJvcGVyIHZhbHVlcyBpbiBhbGwgdGFza3NcbiAgICAgICAgZnVsbFNlc3Npb25Db3B5LnRhc2tzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAvLyBJbml0aWFsaXplIHJldmVhbGVkIHByb3BlcnR5IGlmIG1pc3NpbmdcbiAgICAgICAgICBpZiAodC5yZXZlYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0LnJldmVhbGVkID0gdC5faWQudG9TdHJpbmcoKSA9PT0gdGFza0lkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvciB0aGUgcmV2ZWFsZWQgdGFzaywgbWFrZSBzdXJlIGFsbCBlc3RpbWF0ZSBkYXRhIGlzIGNvbXBsZXRlXG4gICAgICAgICAgaWYgKHQuX2lkLnRvU3RyaW5nKCkgPT09IHRhc2tJZCkge1xuICAgICAgICAgICAgdC5lc3RpbWF0ZXMgPSB0LmVzdGltYXRlcy5tYXAoKGVzdCkgPT4gKHtcbiAgICAgICAgICAgICAgdXNlcklkOiBlc3QudXNlcklkLFxuICAgICAgICAgICAgICB2YWx1ZTogZXN0LnZhbHVlLFxuICAgICAgICAgICAgICBoYXNFc3RpbWF0ZTogZXN0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgZXN0LnZhbHVlICE9PSBudWxsLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2VuZCB0aGUgY29tcGxldGUgc2Vzc2lvbiBkYXRhXG4gICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcInNlc3Npb25fdXBkYXRlXCIsIGZ1bGxTZXNzaW9uQ29weSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmV2ZWFsaW5nIGVzdGltYXRlczpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIGEgbmV3IGV2ZW50IGhhbmRsZXIgZm9yIGhpZGluZyBlc3RpbWF0ZXNcbiAgICBzb2NrZXQub24oXCJoaWRlX2VzdGltYXRlc1wiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0YXNrSWQgfSA9IGRhdGE7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJoaWRlX2VzdGltYXRlcyByZWNlaXZlZDpcIiwge1xuICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgIGZyb21BZG1pbjogZGlzcGxheU5hbWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGNvbm5lY3REQigpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHNlc3Npb25cbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IFNlc3Npb25Nb2RlbC5maW5kQnlJZChzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU2Vzc2lvbiBub3QgZm91bmQ6XCIsIHNlc3Npb25JZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgdGFza1xuICAgICAgICBjb25zdCB0YXNrID0gc2Vzc2lvbi50YXNrcy5maW5kKFxuICAgICAgICAgICh0KSA9PiB0LmlkID09PSB0YXNrSWQgfHwgdC5faWQudG9TdHJpbmcoKSA9PT0gdGFza0lkXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCF0YXNrKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRhc2sgbm90IGZvdW5kIGluIHNlc3Npb246XCIsIHRhc2tJZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHJldmVhbGVkIGZsYWcgdG8gZmFsc2VcbiAgICAgICAgdGFzay5yZXZlYWxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNhdmUgYW5kIGJyb2FkY2FzdCB1cGRhdGVcbiAgICAgICAgYXdhaXQgc2Vzc2lvbi5zYXZlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXN0aW1hdGVzIGhpZGRlbiBmb3IgdGFzazpcIiwgdGFzay50aXRsZSk7XG5cbiAgICAgICAgLy8gQnJvYWRjYXN0IHRoZSBoaWRlIGV2ZW50IGZpcnN0XG4gICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcImVzdGltYXRlc19oaWRkZW5cIiwge1xuICAgICAgICAgIHRhc2tJZDogdGFzay5faWQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFza2VkIHZlcnNpb25cbiAgICAgICAgY29uc3Qgc2Vzc2lvbkZvckJyb2FkY2FzdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbikpO1xuICAgICAgICBzZXNzaW9uRm9yQnJvYWRjYXN0LnRhc2tzLmZvckVhY2goKHQpID0+IHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZWFjaCB0YXNrIGhhcyB0aGUgcmV2ZWFsZWQgcHJvcGVydHlcbiAgICAgICAgICBpZiAodC5yZXZlYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0LnJldmVhbGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhpcyB0YXNrIGlzIG5vdCByZXZlYWxlZCwgaGlkZSBhbGwgZXN0aW1hdGVzIGV4Y2VwdCB0aGUgdXNlcidzIG93blxuICAgICAgICAgIGlmICh0LnJldmVhbGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0LmVzdGltYXRlcyA9IHQuZXN0aW1hdGVzLm1hcCgoZSkgPT4gKHtcbiAgICAgICAgICAgICAgdXNlcklkOiBlLnVzZXJJZCxcbiAgICAgICAgICAgICAgaGFzRXN0aW1hdGU6IGUudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBlLnZhbHVlICE9PSBudWxsLFxuICAgICAgICAgICAgICAvLyBPbmx5IHNob3cgYWN0dWFsIHZhbHVlIHRvIHRoZSB1c2VyIHdobyBzdWJtaXR0ZWQgaXRcbiAgICAgICAgICAgICAgdmFsdWU6IGUudXNlcklkLnRvU3RyaW5nKCkgPT09IHVzZXJJZC50b1N0cmluZygpID8gZS52YWx1ZSA6IG51bGwsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGVuIHNlbmQgbWFza2VkIHNlc3Npb24gdXBkYXRlXG4gICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcInNlc3Npb25fdXBkYXRlXCIsIHNlc3Npb25Gb3JCcm9hZGNhc3QpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhpZGluZyBlc3RpbWF0ZXM6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNvY2tldC5vbihcInNldF9hY3RpdmVfdGFza1wiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW1tZWRpYXRlbHkgYWNrbm93bGVkZ2UgcmVjZWlwdFxuICAgICAgICBzb2NrZXQuZW1pdChcInNldF9hY3RpdmVfdGFza19yZWNlaXZlZFwiLCB7IHRhc2tJZDogZGF0YT8udGFza0lkIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgdGFza0lkIH0gPSBkYXRhIHx8IHt9O1xuXG4gICAgICAgIGlmICghdGFza0lkKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgdGFza0lkIHJlY2VpdmVkOlwiLCBkYXRhKTtcbiAgICAgICAgICBzb2NrZXQuZW1pdChcInNldF9hY3RpdmVfdGFza19lcnJvclwiLCB7IGVycm9yOiBcIkludmFsaWQgdGFzayBJRFwiIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwic2V0X2FjdGl2ZV90YXNrIHJlY2VpdmVkOlwiLCB7XG4gICAgICAgICAgdGFza0lkLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgdGFza0lkVHlwZTogdHlwZW9mIHRhc2tJZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgY29ubmVjdERCKCk7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgc2Vzc2lvblxuICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgU2Vzc2lvbk1vZGVsLmZpbmRCeUlkKHNlc3Npb25JZCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZXNzaW9uIG5vdCBmb3VuZDpcIiwgc2Vzc2lvbklkKTtcbiAgICAgICAgICBzb2NrZXQuZW1pdChcInNldF9hY3RpdmVfdGFza19lcnJvclwiLCB7IGVycm9yOiBcIlNlc3Npb24gbm90IGZvdW5kXCIgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJTZXNzaW9uIHRhc2tzOlwiLFxuICAgICAgICAgIHNlc3Npb24udGFza3MubWFwKCh0KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IHQuaWQsXG4gICAgICAgICAgICBfaWQ6IHQuX2lkPy50b1N0cmluZygpLFxuICAgICAgICAgICAgdGl0bGU6IHQudGl0bGUsXG4gICAgICAgICAgICBzdGF0dXM6IHQuc3RhdHVzLFxuICAgICAgICAgIH0pKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0YXNrIHN0YXR1c1xuICAgICAgICBsZXQgdGFza0ZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRmlyc3QgcGFzczogRmluZCB0aGUgdGFzayB0byBtYWtlIGFjdGl2ZSBhbmQgcmVtZW1iZXIgY3VycmVudCBzdGF0dXMgb2YgYWxsIHRhc2tzXG4gICAgICAgIGNvbnN0IHRhc2tTdGF0dXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHNlc3Npb24udGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhc2tJZFN0ciA9IHRhc2suX2lkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgdGFza1N0YXR1c01hcC5zZXQodGFza0lkU3RyLCB0YXNrLnN0YXR1cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNlY29uZCBwYXNzOiBVcGRhdGUgc3RhdHVzZXNcbiAgICAgICAgc2Vzc2lvbi50YXNrcy5mb3JFYWNoKCh0YXNrKSA9PiB7XG4gICAgICAgICAgLy8gVHJ5IGRpZmZlcmVudCB3YXlzIHRvIG1hdGNoIHRoZSB0YXNrIElEXG4gICAgICAgICAgY29uc3QgdGFza0lkU3RyID0gdGFzay5faWQudG9TdHJpbmcoKTtcbiAgICAgICAgICBjb25zdCB0YXNrSWRNYXRjaGVzID1cbiAgICAgICAgICAgIHRhc2suaWQgPT09IHRhc2tJZCB8fFxuICAgICAgICAgICAgdGFza0lkU3RyID09PSB0YXNrSWQgfHxcbiAgICAgICAgICAgIHRhc2suX2lkLnRvU3RyaW5nKCkgPT09IHRhc2tJZDtcblxuICAgICAgICAgIGlmICh0YXNrSWRNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgdGFzayBhcyBhY3RpdmU6XCIsIHtcbiAgICAgICAgICAgICAgdGl0bGU6IHRhc2sudGl0bGUsXG4gICAgICAgICAgICAgIGlkOiB0YXNrLmlkLFxuICAgICAgICAgICAgICBfaWQ6IHRhc2suX2lkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgIHByZXZpb3VzU3RhdHVzOiB0YXNrLnN0YXR1cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGFzay5zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgICAgICAgICAgdGFza0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRhc2suc3RhdHVzID09PSBcImFjdGl2ZVwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNoYW5naW5nIHByZXZpb3VzbHkgYWN0aXZlIHRhc2sgc3RhdHVzOlwiLCB0YXNrLnRpdGxlKTtcbiAgICAgICAgICAgIC8vIElmIHRhc2sgd2FzIHByZXZpb3VzbHkgY29tcGxldGVkLCBrZWVwIGl0IGNvbXBsZXRlZFxuICAgICAgICAgICAgaWYgKHRhc2tTdGF0dXNNYXAuZ2V0KHRhc2tJZFN0cikgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICAgICAgdGFzay5zdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTWFyayBwcmV2aW91cyBhY3RpdmUgdGFzayBhcyBjb21wbGV0ZWQgd2hlbiBtb3ZpbmcgdG8gYSBuZXcgdGFza1xuICAgICAgICAgICAgICB0YXNrLnN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEtlZXAgb3RoZXIgdGFza3MgYXMgdGhleSBhcmUgKHBlbmRpbmcgb3IgY29tcGxldGVkKVxuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGNvbXBsZXRlZCB0YXNrcyBzdGF5IGNvbXBsZXRlZFxuICAgICAgICAgICAgY29uc29sZS5sb2coYEtlZXBpbmcgdGFzayBcIiR7dGFzay50aXRsZX1cIiBhcyAke3Rhc2suc3RhdHVzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0YXNrRm91bmQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gbWF0Y2hpbmcgdGFzayBmb3VuZDpcIiwgdGFza0lkKTtcbiAgICAgICAgICBzb2NrZXQuZW1pdChcInNldF9hY3RpdmVfdGFza19lcnJvclwiLCB7IGVycm9yOiBcIlRhc2sgbm90IGZvdW5kXCIgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB1cGRhdGVkIHNlc3Npb25cbiAgICAgICAgYXdhaXQgc2Vzc2lvbi5zYXZlKCk7XG5cbiAgICAgICAgLy8gU2VuZCBzdWNjZXNzIHJlc3BvbnNlXG4gICAgICAgIHNvY2tldC5lbWl0KFwic2V0X2FjdGl2ZV90YXNrX3N1Y2Nlc3NcIiwge1xuICAgICAgICAgIHRhc2tJZCxcbiAgICAgICAgICBtZXNzYWdlOiBcIlRhc2sgc2V0IGFzIGFjdGl2ZSBzdWNjZXNzZnVsbHlcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQnJvYWRjYXN0IHNlc3Npb24gdXBkYXRlIHRvIGFsbCB1c2Vyc1xuICAgICAgICBpby50byhzZXNzaW9uSWQpLmVtaXQoXCJzZXNzaW9uX3VwZGF0ZVwiLCBzZXNzaW9uKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlRhc2sgc2V0IGFzIGFjdGl2ZSwgc2Vzc2lvbiB1cGRhdGVkXCIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgYWN0aXZlIHRhc2s6XCIsIGVycm9yKTtcbiAgICAgICAgc29ja2V0LmVtaXQoXCJzZXRfYWN0aXZlX3Rhc2tfZXJyb3JcIiwge1xuICAgICAgICAgIGVycm9yOiBcIlNlcnZlciBlcnJvciBwcm9jZXNzaW5nIHJlcXVlc3RcIixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzb2NrZXQub24oXCJhZGRfdGFza1wiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgLy8gRmlyc3QgYWNrbm93bGVkZ2UgcmVjZWlwdCB0byBrZWVwIHRoZSBzb2NrZXQgb3BlblxuICAgICAgc29ja2V0LmVtaXQoXCJhZGRfdGFza19yZWNlaXZlZFwiLCB7XG4gICAgICAgIHN0YXR1czogXCJyZWNlaXZlZFwiLFxuICAgICAgICBtZXNzYWdlOiBcIlRhc2sgcmVxdWVzdCByZWNlaXZlZCBieSBzZXJ2ZXJcIixcbiAgICAgICAgdGFza0RhdGE6IGRhdGEsXG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0aXRsZSwgZGVzY3JpcHRpb24sIGppcmFJZCB9ID0gZGF0YTtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZGRfdGFzayByZWNlaXZlZCBmcm9tOlwiLCBkaXNwbGF5TmFtZSwgXCIoXCIsIHVzZXJJZCwgXCIpXCIsIHtcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICBqaXJhSWQsXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEb3VibGUtY2hlY2sgY29ubmVjdGlvblxuICAgICAgICBpZiAoIXNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU29ja2V0IGRpc2Nvbm5lY3RlZCBkdXJpbmcgdGFzayBjcmVhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGNvbm5lY3REQigpO1xuXG4gICAgICAgICAgLy8gRmluZCB0aGUgc2Vzc2lvblxuICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBTZXNzaW9uTW9kZWwuZmluZEJ5SWQoc2Vzc2lvbklkKTtcbiAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZXNzaW9uIG5vdCBmb3VuZDpcIiwgc2Vzc2lvbklkKTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiYWRkX3Rhc2tfZXJyb3JcIiwgeyBlcnJvcjogXCJTZXNzaW9uIG5vdCBmb3VuZFwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdGFzayB3aXRoIHByb3BlciBNb25nb0RCIGRvY3VtZW50IHN0cnVjdHVyZVxuICAgICAgICAgIGNvbnN0IG5ld1Rhc2sgPSB7XG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgICAgamlyYUlkOiBqaXJhSWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIGVzdGltYXRlczogW10sXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIEFkZCB0YXNrIHRvIHNlc3Npb25cbiAgICAgICAgICBzZXNzaW9uLnRhc2tzLnB1c2gobmV3VGFzayk7XG4gICAgICAgICAgY29uc3QgbmV3VGFza0lkID0gc2Vzc2lvbi50YXNrc1tzZXNzaW9uLnRhc2tzLmxlbmd0aCAtIDFdLl9pZDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRhc2sgYWRkZWQ6XCIsIHtcbiAgICAgICAgICAgIHRpdGxlOiBuZXdUYXNrLnRpdGxlLFxuICAgICAgICAgICAgdGFza0lkOiBuZXdUYXNrSWQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTYXZlIHNlc3Npb24gaW4gYSBzZXBhcmF0ZSB0cnkgYmxvY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgc2Vzc2lvbi5zYXZlKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlc3Npb24gc2F2ZWQgd2l0aCBuZXcgdGFzaywgZW1pdHRpbmcgcmVzcG9uc2VcIik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNvY2tldCBpcyBzdGlsbCBjb25uZWN0ZWRcbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIC8vIEZpcnN0IHNlbmQgYSBzdWNjZXNzIGNvbmZpcm1hdGlvbiB0byB0aGUgdGFzayBjcmVhdG9yXG4gICAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiYWRkX3Rhc2tfc3VjY2Vzc1wiLCB7XG4gICAgICAgICAgICAgICAgdGFza0lkOiBuZXdUYXNrSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRhc2sgY3JlYXRlZCBzdWNjZXNzZnVsbHlcIixcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gVGhlbiBicm9hZGNhc3QgdG8gYWxsIHVzZXJzIGluIHRoZSByb29tXG4gICAgICAgICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcInNlc3Npb25fdXBkYXRlXCIsIHNlc3Npb24pO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlc3Npb24gdXBkYXRlIGVtaXR0ZWQgdG8gcm9vbVwiLCBzZXNzaW9uSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiU29ja2V0IGRpc2Nvbm5lY3RlZCBiZWZvcmUgc2VuZGluZyBzdWNjZXNzIHJlc3BvbnNlXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChzYXZlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmcgc2Vzc2lvbjpcIiwgc2F2ZUVycm9yKTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiYWRkX3Rhc2tfZXJyb3JcIiwgeyBlcnJvcjogXCJGYWlsZWQgdG8gc2F2ZSB0YXNrXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChkYkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkRhdGFiYXNlIGVycm9yOlwiLCBkYkVycm9yKTtcbiAgICAgICAgICBpZiAoc29ja2V0LmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgc29ja2V0LmVtaXQoXCJhZGRfdGFza19lcnJvclwiLCB7IGVycm9yOiBcIkRhdGFiYXNlIGVycm9yXCIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHRhc2s6XCIsIGVycm9yKTtcbiAgICAgICAgaWYgKHNvY2tldC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICBzb2NrZXQuZW1pdChcImFkZF90YXNrX2Vycm9yXCIsIHtcbiAgICAgICAgICAgIGVycm9yOiBcIlNlcnZlciBlcnJvciBwcm9jZXNzaW5nIHRhc2tcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc29ja2V0Lm9uKFwicmVmcmVzaF9zZXNzaW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNvbm5lY3REQigpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHNlc3Npb25cbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IFNlc3Npb25Nb2RlbC5maW5kQnlJZChzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoIXNlc3Npb24pIHJldHVybjtcblxuICAgICAgICAvLyBDcmVhdGUgYSBwcm9wZXIgY29weSBvZiB0aGUgc2Vzc2lvbiB3aXRoIGNvbnNpc3RlbnQgZm9ybWF0dGluZ1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRTZXNzaW9uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXNzaW9uKSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIGFsbCB0YXNrcyBoYXZlIHByb3BlciByZXZlYWxlZCBzdGF0ZSBhbmQgZXN0aW1hdGUgZm9ybWF0dGluZ1xuICAgICAgICBwcm9jZXNzZWRTZXNzaW9uLnRhc2tzLmZvckVhY2goKHRhc2spID0+IHtcbiAgICAgICAgICAvLyBJbml0aWFsaXplIHJldmVhbGVkIGlmIG1pc3NpbmdcbiAgICAgICAgICBpZiAodGFzay5yZXZlYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0YXNrLnJldmVhbGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRm9yIG5vbi1yZXZlYWxlZCB0YXNrcywgbWFzayBlc3RpbWF0ZXMgZXhjZXB0IGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAgICAgICAgaWYgKHRhc2sucmV2ZWFsZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRhc2suZXN0aW1hdGVzID0gdGFzay5lc3RpbWF0ZXMubWFwKChlc3QpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50VXNlciA9XG4gICAgICAgICAgICAgICAgZXN0LnVzZXJJZCAmJiBlc3QudXNlcklkLnRvU3RyaW5nKCkgPT09IHVzZXJJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICBjb25zdCBoYXNWYWx1ZSA9IGVzdC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGVzdC52YWx1ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogZXN0LnVzZXJJZCxcbiAgICAgICAgICAgICAgICBoYXNFc3RpbWF0ZTogaGFzVmFsdWUgfHwgZXN0Lmhhc0VzdGltYXRlID09PSB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgc2hvdyBhY3R1YWwgdmFsdWUgdG8gY3VycmVudCB1c2VyXG4gICAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgICBpc0N1cnJlbnRVc2VyICYmIGhhc1ZhbHVlXG4gICAgICAgICAgICAgICAgICAgID8gZXN0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaXNDdXJyZW50VXNlclxuICAgICAgICAgICAgICAgICAgICA/IFwiLVwiXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgcmV2ZWFsZWQgdGFza3MsIGVuc3VyZSBhbGwgZXN0aW1hdGVzIGhhdmUgY29uc2lzdGVudCBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHRhc2suZXN0aW1hdGVzID0gdGFzay5lc3RpbWF0ZXMubWFwKChlc3QpID0+ICh7XG4gICAgICAgICAgICAgIHVzZXJJZDogZXN0LnVzZXJJZCxcbiAgICAgICAgICAgICAgdmFsdWU6IGVzdC52YWx1ZSxcbiAgICAgICAgICAgICAgaGFzRXN0aW1hdGU6IGVzdC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGVzdC52YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEJyb2FkY2FzdCB0aGUgcHJvY2Vzc2VkIHNlc3Npb24gdXBkYXRlXG4gICAgICAgIGlvLnRvKHNlc3Npb25JZCkuZW1pdChcInNlc3Npb25fdXBkYXRlXCIsIHByb2Nlc3NlZFNlc3Npb24pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlZnJlc2hpbmcgc2Vzc2lvbjpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc29ja2V0Lm9uKFwic2V0X2ZpbmFsX2VzdGltYXRlXCIsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHRhc2tJZCwgZXN0aW1hdGUgfSA9IGRhdGE7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJzZXRfZmluYWxfZXN0aW1hdGUgcmVjZWl2ZWQ6XCIsIHtcbiAgICAgICAgICB0YXNrSWQsXG4gICAgICAgICAgZXN0aW1hdGUsXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICBmcm9tQWRtaW46IGRpc3BsYXlOYW1lLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBjb25uZWN0REIoKTtcblxuICAgICAgICAvLyBGaW5kIHRoZSBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBTZXNzaW9uTW9kZWwuZmluZEJ5SWQoc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlNlc3Npb24gbm90IGZvdW5kOlwiLCBzZXNzaW9uSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHRhc2tcbiAgICAgICAgY29uc3QgdGFzayA9IHNlc3Npb24udGFza3MuZmluZChcbiAgICAgICAgICAodCkgPT4gdC5pZCA9PT0gdGFza0lkIHx8IHQuX2lkLnRvU3RyaW5nKCkgPT09IHRhc2tJZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUYXNrIG5vdCBmb3VuZCBpbiBzZXNzaW9uOlwiLCB0YXNrSWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBmaW5hbCBlc3RpbWF0ZSBhbmQgbWFyayB0YXNrIGFzIGNvbXBsZXRlZFxuICAgICAgICB0YXNrLmZpbmFsRXN0aW1hdGUgPSBlc3RpbWF0ZTtcbiAgICAgICAgdGFzay5zdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgICAgICB0YXNrLnJldmVhbGVkID0gdHJ1ZTsgLy8gTWFrZSBzdXJlIGVzdGltYXRlcyBhcmUgcmV2ZWFsZWQgd2l0aCBmaW5hbCBlc3RpbWF0ZVxuXG4gICAgICAgIC8vIFNhdmUgYW5kIGJyb2FkY2FzdCB1cGRhdGVcbiAgICAgICAgYXdhaXQgc2Vzc2lvbi5zYXZlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmluYWwgZXN0aW1hdGUgc2V0IGZvciB0YXNrOlwiLCB0YXNrLnRpdGxlLCBcIj1cIiwgZXN0aW1hdGUpO1xuXG4gICAgICAgIC8vIEJyb2FkY2FzdCB0YXNrIGNvbXBsZXRlZCBldmVudFxuICAgICAgICBpby50byhzZXNzaW9uSWQpLmVtaXQoXCJ0YXNrX2NvbXBsZXRlZFwiLCB7XG4gICAgICAgICAgdGFza0lkOiB0YXNrLl9pZC50b1N0cmluZygpLFxuICAgICAgICAgIGZpbmFsRXN0aW1hdGU6IGVzdGltYXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZW5kIGZ1bGwgc2Vzc2lvbiB1cGRhdGVcbiAgICAgICAgaW8udG8oc2Vzc2lvbklkKS5lbWl0KFwic2Vzc2lvbl91cGRhdGVcIiwgc2Vzc2lvbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2V0dGluZyBmaW5hbCBlc3RpbWF0ZTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGRpc2Nvbm5lY3Rpb25cbiAgICBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gY29ubmVjdGVkVXNlcnMuZ2V0KHNvY2tldC5pZCk7XG4gICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgYFVzZXIgJHt1c2VyRGF0YS51c2VybmFtZX0gZGlzY29ubmVjdGVkIGZyb20gc2Vzc2lvbiAke3VzZXJEYXRhLnNlc3Npb25JZH1gXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gY29ubmVjdGVkIHVzZXJzXG4gICAgICAgIGNvbm5lY3RlZFVzZXJzLmRlbGV0ZShzb2NrZXQuaWQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzZXNzaW9uIHBhcnRpY2lwYW50c1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2Vzc2lvblBhcnRpY2lwYW50cy5oYXModXNlckRhdGEuc2Vzc2lvbklkKSAmJlxuICAgICAgICAgIHNlc3Npb25QYXJ0aWNpcGFudHMuZ2V0KHVzZXJEYXRhLnNlc3Npb25JZCkuaGFzKHVzZXJEYXRhLnVzZXJJZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2Vzc2lvblBhcnRpY2lwYW50c1xuICAgICAgICAgICAgLmdldCh1c2VyRGF0YS5zZXNzaW9uSWQpXG4gICAgICAgICAgICAuZ2V0KHVzZXJEYXRhLnVzZXJJZCkuY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBTZW5kIHVwZGF0ZWQgcGFydGljaXBhbnQgbGlzdFxuICAgICAgICAgIGNvbnN0IHBhcnRpY2lwYW50c0xpc3QgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgc2Vzc2lvblBhcnRpY2lwYW50cy5nZXQodXNlckRhdGEuc2Vzc2lvbklkKS5lbnRyaWVzKClcbiAgICAgICAgICApLm1hcCgoW2lkLCBkYXRhXSkgPT4gKHtcbiAgICAgICAgICAgIHVzZXJJZDogaWQsXG4gICAgICAgICAgICB1c2VybmFtZTogZGF0YS51c2VybmFtZSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogZGF0YS5jb25uZWN0ZWQsXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaW8udG8odXNlckRhdGEuc2Vzc2lvbklkKS5lbWl0KFxuICAgICAgICAgICAgXCJwYXJ0aWNpcGFudHNfdXBkYXRlXCIsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudHNMaXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHNlc3Npb24gcm9vbVxuICAgICAgICBpZiAoc2Vzc2lvblJvb21zLmhhcyh1c2VyRGF0YS5zZXNzaW9uSWQpKSB7XG4gICAgICAgICAgc2Vzc2lvblJvb21zLmdldCh1c2VyRGF0YS5zZXNzaW9uSWQpLmRlbGV0ZShzb2NrZXQuaWQpO1xuXG4gICAgICAgICAgLy8gSWYgcm9vbSBpcyBlbXB0eSwgY2xlYW51cFxuICAgICAgICAgIGlmIChzZXNzaW9uUm9vbXMuZ2V0KHVzZXJEYXRhLnNlc3Npb25JZCkuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgc2Vzc2lvblJvb21zLmRlbGV0ZSh1c2VyRGF0YS5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgc2Vzc2lvblBhcnRpY2lwYW50cy5kZWxldGUodXNlckRhdGEuc2Vzc2lvbklkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RpZnkgb3RoZXIgdXNlcnMgaW4gdGhlIHJvb21cbiAgICAgICAgc29ja2V0LnRvKHVzZXJEYXRhLnNlc3Npb25JZCkuZW1pdChcInVzZXJfbGVmdFwiLCB7XG4gICAgICAgICAgdXNlcklkOiB1c2VyRGF0YS51c2VySWQsXG4gICAgICAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmVzLmVuZCgpO1xufVxuIl0sIm5hbWVzIjpbIlNlcnZlciIsIm1vbmdvb3NlIiwiU2Vzc2lvbk1vZGVsIiwibW9kZWwiLCJlIiwiU2Vzc2lvblNjaGVtYSIsIlNjaGVtYSIsIm5hbWUiLCJ0eXBlIiwiU3RyaW5nIiwicmVxdWlyZWQiLCJvd25lcklkIiwicGFydGljaXBhbnRzIiwidGFza3MiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiamlyYUlkIiwic3RhdHVzIiwiZW51bSIsImRlZmF1bHQiLCJlc3RpbWF0ZXMiLCJ1c2VySWQiLCJ2YWx1ZSIsIlR5cGVzIiwiTWl4ZWQiLCJmaW5hbEVzdGltYXRlIiwiZXN0aW1hdGlvblR5cGUiLCJzaGFyZUxpbmsiLCJjb25uZWN0REIiLCJjb25uZWN0aW9uIiwicmVhZHlTdGF0ZSIsImNvbm5lY3QiLCJwcm9jZXNzIiwiZW52IiwiTU9OR09EQl9VUkkiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJjb25uZWN0ZWRVc2VycyIsIk1hcCIsInNlc3Npb25Sb29tcyIsInNlc3Npb25QYXJ0aWNpcGFudHMiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwic29ja2V0Iiwic2VydmVyIiwiaW8iLCJlbmQiLCJwYXRoIiwiYWRkVHJhaWxpbmdTbGFzaCIsIm9uIiwic2Vzc2lvbklkIiwidXNlcm5hbWUiLCJoYW5kc2hha2UiLCJxdWVyeSIsImRpc2Nvbm5lY3QiLCJkaXNwbGF5TmFtZSIsInRyaW0iLCJzdWJzdHJpbmciLCJqb2luIiwic2V0IiwiaWQiLCJoYXMiLCJnZXQiLCJjb25uZWN0ZWQiLCJTZXQiLCJhZGQiLCJwYXJ0aWNpcGFudHNMaXN0IiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsImRhdGEiLCJ0byIsImVtaXQiLCJtZXNzYWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInRhc2tJZCIsInNlc3Npb24iLCJmaW5kQnlJZCIsInRhc2siLCJmaW5kIiwidCIsIl9pZCIsInRvU3RyaW5nIiwiZXhpc3RpbmdFc3RpbWF0ZUluZGV4IiwiZmluZEluZGV4IiwiaGFzQWN0dWFsVmFsdWUiLCJ1bmRlZmluZWQiLCJoYXNFc3RpbWF0ZSIsInB1c2giLCJyZXZlYWxlZCIsInNhdmUiLCJzZXNzaW9uRm9yQnJvYWRjYXN0IiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZm9yRWFjaCIsImlzQ3VycmVudFVzZXIiLCJoYXNWYWx1ZSIsImZyb21BZG1pbiIsImNsZWFuRXN0aW1hdGVzIiwiZXN0IiwiZnVsbFNlc3Npb25Db3B5IiwidGFza0lkVHlwZSIsInRhc2tGb3VuZCIsInRhc2tTdGF0dXNNYXAiLCJ0YXNrSWRTdHIiLCJ0YXNrSWRNYXRjaGVzIiwicHJldmlvdXNTdGF0dXMiLCJ0YXNrRGF0YSIsIm5ld1Rhc2siLCJuZXdUYXNrSWQiLCJsZW5ndGgiLCJ3YXJuIiwic2F2ZUVycm9yIiwiZGJFcnJvciIsInByb2Nlc3NlZFNlc3Npb24iLCJlc3RpbWF0ZSIsInVzZXJEYXRhIiwiZGVsZXRlIiwic2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./src/pages/api/socketio.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fsocketio&preferredRegion=&absolutePagePath=.%2Fsrc%2Fpages%2Fapi%2Fsocketio.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();