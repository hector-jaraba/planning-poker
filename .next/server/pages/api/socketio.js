"use strict";(()=>{var e={};e.id=230,e.ids=[230],e.modules={20145:e=>{e.exports=require("next/dist/compiled/next-server/pages-api.runtime.prod.js")},20533:(e,t,s)=>{let i;s.r(t),s.d(t,{config:()=>p,default:()=>v,routeModule:()=>f});var o={};s.r(o),s.d(o,{default:()=>handler});var a=s(71802),r=s(47153),n=s(56249);let d=require("socket.io"),l=require("mongoose");var c=s.n(l);try{i=c().model("Session")}catch(t){let e=new(c()).Schema({name:{type:String,required:!0},ownerId:{type:String,required:!0},participants:[String],tasks:[{title:{type:String,required:!0},description:String,jiraId:String,status:{type:String,enum:["pending","active","completed"],default:"pending"},estimates:[{userId:String,value:c().Schema.Types.Mixed}],finalEstimate:c().Schema.Types.Mixed}],estimationType:{type:String,enum:["fibonacci","tshirt"],default:"fibonacci"},status:{type:String,enum:["active","completed"],default:"active"},shareLink:String,admins:[c().Types.ObjectId]});i=c().model("Session",e)}let connectDB=async()=>{try{0===c().connection.readyState&&(await c().connect(process.env.MONGODB_URI),console.log("MongoDB connected"))}catch(e){console.error("MongoDB connection error:",e)}},m=new Map,u=new Map,g=new Map;function handler(e,t){if(t.socket.server.io){console.log("Socket is already running"),t.end();return}console.log("Setting up socket.io server...");let s=new d.Server(t.socket.server,{path:"/api/socketio",addTrailingSlash:!1});t.socket.server.io=s,s.on("connection",async e=>{let{sessionId:t,userId:o,username:a}=e.handshake.query;if(!t||!o){e.disconnect();return}let r=a&&String(a).trim()||`User ${o.substring(0,6)}`;console.log(`User ${r} (${o}) connected to session ${t}`),e.join(t),m.set(e.id,{userId:o,username:r,sessionId:t}),g.has(t)||g.set(t,new Map),g.get(t).set(o,{username:r,connected:!0}),u.has(t)||u.set(t,new Set),u.get(t).add(e.id);let n=Array.from(g.get(t).entries()).map(([e,t])=>({userId:e,username:t.username,connected:t.connected}));console.log("Broadcasting participants list:",n),s.to(t).emit("participants_update",n),e.to(t).emit("user_joined",{userId:o,username:r}),e.on("ping",t=>{console.log(`Ping received from ${r} (${o}):`,t),e.emit("pong",{message:"Server received ping",timestamp:Date.now()})}),e.on("submit_estimate",async e=>{try{let{taskId:a,value:n}=e;console.log("submit_estimate received:",{taskId:a,value:n,userId:o,sessionId:t}),await connectDB();let d=await i.findById(t);if(!d){console.error("Session not found:",t);return}let l=d.tasks.find(e=>e.id===a||e._id.toString()===a);if(!l){console.error("Task not found in session:",a);return}console.log("Processing estimate for task:",l.title);let c=l.estimates.findIndex(e=>e.userId.toString()===o.toString()),m=null!=n&&"?"!==n;c>=0?(console.log("Updating existing estimate for user:",o),l.estimates[c].value=m?n:null,l.estimates[c].hasEstimate=m):(console.log("Adding new estimate for user:",o),l.estimates.push({userId:o,value:m?n:null,hasEstimate:m})),void 0===l.revealed&&(l.revealed=!1),await d.save(),console.log("Session saved with new estimate, emitting update");let u=JSON.parse(JSON.stringify(d));u.tasks.forEach(e=>{void 0===e.revealed&&(e.revealed=!1),!0!==e.revealed&&(e.estimates=e.estimates.map(e=>{let t=e.userId.toString()===o.toString(),s=void 0!==e.value&&null!==e.value;return{userId:e.userId,hasEstimate:s||!0===e.hasEstimate,value:t&&s?e.value:t?"-":null}}))}),console.log("Broadcasting session update with hidden estimates"),s.to(t).emit("session_update",u),s.to(t).emit("user_estimated",{userId:o,username:r,taskId:l._id.toString()})}catch(e){console.error("Error submitting estimate:",e)}}),e.on("reveal_estimates",async e=>{try{let{taskId:a}=e;console.log("reveal_estimates received:",{taskId:a,userId:o,sessionId:t,fromAdmin:r}),await connectDB();let n=await i.findById(t);if(!n){console.error("Session not found:",t);return}let d=n.tasks.find(e=>e.id===a||e._id.toString()===a);if(!d){console.error("Task not found in session:",a);return}d.revealed=!0,await n.save(),console.log("Estimates revealed for task:",d.title);let l=d.estimates.map(e=>({userId:e.userId?e.userId.toString():e.userId,value:e.value,hasEstimate:void 0!==e.value&&null!==e.value}));console.log("Sending revealed estimates:",l),s.to(t).emit("estimates_revealed",{taskId:d._id.toString(),estimates:l});let c=JSON.parse(JSON.stringify(n));c.tasks.forEach(e=>{void 0===e.revealed&&(e.revealed=e._id.toString()===a),e._id.toString()===a&&(e.estimates=e.estimates.map(e=>({userId:e.userId,value:e.value,hasEstimate:void 0!==e.value&&null!==e.value})))}),s.to(t).emit("session_update",c)}catch(e){console.error("Error revealing estimates:",e)}}),e.on("hide_estimates",async e=>{try{let{taskId:a}=e;console.log("hide_estimates received:",{taskId:a,userId:o,sessionId:t,fromAdmin:r}),await connectDB();let n=await i.findById(t);if(!n){console.error("Session not found:",t);return}let d=n.tasks.find(e=>e.id===a||e._id.toString()===a);if(!d){console.error("Task not found in session:",a);return}d.revealed=!1,await n.save(),console.log("Estimates hidden for task:",d.title),s.to(t).emit("estimates_hidden",{taskId:d._id.toString()});let l=JSON.parse(JSON.stringify(n));l.tasks.forEach(e=>{void 0===e.revealed&&(e.revealed=!1),!0!==e.revealed&&(e.estimates=e.estimates.map(e=>({userId:e.userId,hasEstimate:void 0!==e.value&&null!==e.value,value:e.userId.toString()===o.toString()?e.value:null})))}),s.to(t).emit("session_update",l)}catch(e){console.error("Error hiding estimates:",e)}}),e.on("set_active_task",async a=>{try{e.emit("set_active_task_received",{taskId:a?.taskId});let{taskId:r}=a||{};if(!r){console.error("Invalid taskId received:",a),e.emit("set_active_task_error",{error:"Invalid task ID"});return}console.log("set_active_task received:",{taskId:r,userId:o,sessionId:t,taskIdType:typeof r}),await connectDB();let n=await i.findById(t);if(!n){console.error("Session not found:",t),e.emit("set_active_task_error",{error:"Session not found"});return}console.log("Session tasks:",n.tasks.map(e=>({id:e.id,_id:e._id?.toString(),title:e.title,status:e.status})));let d=!1,l=new Map;if(n.tasks.forEach(e=>{let t=e._id.toString();l.set(t,e.status)}),n.tasks.forEach(e=>{let t=e._id.toString(),s=e.id===r||t===r||e._id.toString()===r;s?(console.log("Setting task as active:",{title:e.title,id:e.id,_id:e._id.toString(),previousStatus:e.status}),e.status="active",d=!0):"active"===e.status?(console.log("Changing previously active task status:",e.title),"completed"===l.get(t)?e.status="completed":e.finalEstimate||e.estimates&&e.estimates.length>0?(console.log(`Task "${e.title}" has estimates, marking as completed`),e.status="completed"):(console.log(`Task "${e.title}" has no estimates, returning to pending`),e.status="pending")):console.log(`Keeping task "${e.title}" as ${e.status}`)}),!d){console.error("No matching task found:",r),e.emit("set_active_task_error",{error:"Task not found"});return}await n.save(),e.emit("set_active_task_success",{taskId:r,message:"Task set as active successfully"}),s.to(t).emit("session_update",n),console.log("Task set as active, session updated")}catch(t){console.error("Error setting active task:",t),e.emit("set_active_task_error",{error:"Server error processing request"})}}),e.on("add_task",async a=>{e.emit("add_task_received",{status:"received",message:"Task request received by server",taskData:a});try{let{title:n,description:d,jiraId:l}=a;if(console.log("add_task received from:",r,"(",o,")",{title:n,description:d,jiraId:l,sessionId:t}),!e.connected){console.error("Socket disconnected during task creation");return}try{await connectDB();let o=await i.findById(t);if(!o){console.error("Session not found:",t),e.connected&&e.emit("add_task_error",{error:"Session not found"});return}let a={title:n,description:d||"",jiraId:l||void 0,status:"pending",estimates:[]};o.tasks.push(a);let r=o.tasks[o.tasks.length-1]._id;console.log("Task added:",{title:a.title,taskId:r});try{await o.save(),console.log("Session saved with new task, emitting response"),e.connected?(e.emit("add_task_success",{taskId:r.toString(),message:"Task created successfully"}),s.to(t).emit("session_update",o),console.log("Session update emitted to room",t)):console.warn("Socket disconnected before sending success response")}catch(t){console.error("Error saving session:",t),e.connected&&e.emit("add_task_error",{error:"Failed to save task"})}}catch(t){console.error("Database error:",t),e.connected&&e.emit("add_task_error",{error:"Database error"})}}catch(t){console.error("Error adding task:",t),e.connected&&e.emit("add_task_error",{error:"Server error processing task"})}}),e.on("refresh_session",async()=>{try{await connectDB();let e=await i.findById(t);if(!e)return;let a=JSON.parse(JSON.stringify(e));a.tasks.forEach(e=>{void 0===e.revealed&&(e.revealed=!1),!0!==e.revealed?e.estimates=e.estimates.map(e=>{let t=e.userId&&e.userId.toString()===o.toString(),s=void 0!==e.value&&null!==e.value;return{userId:e.userId,hasEstimate:s||!0===e.hasEstimate,value:t&&s?e.value:t?"-":null}}):e.estimates=e.estimates.map(e=>({userId:e.userId,value:e.value,hasEstimate:void 0!==e.value&&null!==e.value}))}),s.to(t).emit("session_update",a)}catch(e){console.error("Error refreshing session:",e)}}),e.on("set_final_estimate",async e=>{try{let{taskId:a,estimate:n}=e;console.log("set_final_estimate received:",{taskId:a,estimate:n,userId:o,sessionId:t,fromAdmin:r}),await connectDB();let d=await i.findById(t);if(!d){console.error("Session not found:",t);return}let l=d.tasks.find(e=>e.id===a||e._id.toString()===a);if(!l){console.error("Task not found in session:",a);return}l.finalEstimate=n,l.status="completed",l.revealed=!0;let c=d.tasks.every(e=>"completed"===e.status);c&&(console.log("All tasks completed, marking session as completed"),d.status="completed"),await d.save(),console.log("Final estimate set for task:",l.title,"=",n),s.to(t).emit("task_completed",{taskId:l._id.toString(),finalEstimate:n}),s.to(t).emit("session_update",d)}catch(e){console.error("Error setting final estimate:",e)}}),e.on("disconnect",()=>{let t=m.get(e.id);if(t){if(console.log(`User ${t.username} disconnected from session ${t.sessionId}`),m.delete(e.id),g.has(t.sessionId)&&g.get(t.sessionId).has(t.userId)){g.get(t.sessionId).get(t.userId).connected=!1;let e=Array.from(g.get(t.sessionId).entries()).map(([e,t])=>({userId:e,username:t.username,connected:t.connected}));s.to(t.sessionId).emit("participants_update",e)}u.has(t.sessionId)&&(u.get(t.sessionId).delete(e.id),0===u.get(t.sessionId).size&&(u.delete(t.sessionId),g.delete(t.sessionId))),e.to(t.sessionId).emit("user_left",{userId:t.userId,username:t.username})}}),e.on("make_admin",async a=>{try{let{targetUserId:r}=a,n=await i.findById(t);if(!n){e.emit("error",{message:"Session not found"});return}let d=n.ownerId.toString()===o.toString(),l=n.admins?.some(e=>e.toString()===o.toString());if(!d&&!l){e.emit("error",{message:"Only the session owner or admins can manage admin permissions"});return}n.admins||(n.admins=[]),n.admins.some(e=>e.toString()===r.toString())||(n.admins.push(new(c()).Types.ObjectId(r)),await n.save(),s.to(t).emit("session_update",n))}catch(t){console.error("Failed to make user admin:",t),e.emit("error",{message:"Failed to make user admin"})}}),e.on("remove_admin",async a=>{try{let{targetUserId:r}=a,n=await i.findById(t);if(!n){e.emit("error",{message:"Session not found"});return}let d=n.ownerId.toString()===o.toString(),l=n.admins?.some(e=>e.toString()===o.toString());if(!d&&!l){e.emit("error",{message:"Only the session owner or admins can manage admin permissions"});return}n.admins=n.admins.filter(e=>e.toString()!==r.toString()),await n.save(),s.to(t).emit("session_update",n)}catch(t){console.error("Failed to remove admin:",t),e.emit("error",{message:"Failed to remove admin"})}})}),t.end()}let v=(0,n.l)(o,"default"),p=(0,n.l)(o,"config"),f=new a.PagesAPIRouteModule({definition:{kind:r.x.PAGES_API,page:"/api/socketio",pathname:"/api/socketio",bundlePath:"",filename:""},userland:o})}};var t=require("../../webpack-api-runtime.js");t.C(e);var __webpack_exec__=e=>t(t.s=e),s=t.X(0,[222],()=>__webpack_exec__(20533));module.exports=s})();